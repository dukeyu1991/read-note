# 发送消息及消费

## 绑定消费者
使用basic.consumer命令将订阅消息。订阅消息之后，消费者在消费（或者拒绝）消息后，会自动接收下一条消息。  
可以使用basic.get来向队列请求单条消息。如果需要再获取数据，需要再次调用basic.get来获取。  
如果将basic.get放在一个循环里面代替basic.consumer，会极大的影响rabbitmq的性能。  
### 队列消息的分发
当消息到达无人订阅的队列时，消息会一直等待，直到有消费者订阅该队列。  
如果至少有一个消费者已经订阅了队列，则消息到达后立即发送给这些订阅的消费者。  

--
如果有多个消费者订阅了该队列，那消息如何发送？  
答：队列采用循环的方式发给订阅者，且只会发送给一个订阅者。譬如有A和B两个消费者订阅了Queue。则Message_A到queue后，发送给A，确定A回复后删除消息。接着Message_B到queue后，发送给B，确定B回复后删除消息。  

 
什么情况下，不会再将消息推给特定的消费者？  
答：1. 确认之前，从rabbitmq断开（或取消订阅），rmq会将该消息丢给下一个订阅的消费者。  
2. 应用程序有bug未确认消息，rmq不再会给该应用程序推送消息了。 

只是想明确拒绝消息，而想继续接受消息，怎么处理?  
答： basic.reject，里面有参数requeue。设置为true，则会重新分发给下一个订阅者，否则直接删除该消息。

### 消费者确定消息
通过basic.ack显性地向rabbitmq发送一个确认。或者在订阅队列时设置auto_ack为true，则一旦消费者接受消息，rabbitmq会自动视其确认了消息。  

### 如何创造队列
queue.declare命令创建queue。通常需要指定一个队列名字，不指定的话，rabbitmq会自动生成一个。  
exclusive设置为ture，队列变成私有，只要你的应用程序才能消费队列消息。  
auto-delete设置为ture，但最后一个消费者取消订阅时，队列被自动移除。


